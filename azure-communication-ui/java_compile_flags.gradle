import java.util.regex.Pattern
import java.util.regex.Matcher

//    ## For Gradle Users
//
//    ### Listing Flags
//
//    To list all the feature flags in your project and their current status (Enabled or Disabled), use the `listFlags` task:
//
//    ```shell
//    gradlew listFlags
//    ```
//
//    This will print out all the feature flags in your project and their current status.
//
//    ### Toggling Flags
//
//    To toggle the status of a feature flag, use the `toggleFlag` task with the `-PflagName=YOUR_FLAG_NAME` argument:
//
//    ```shell
//    gradlew toggleFlag -PflagName=YOUR_FLAG_NAME
//    ```
//
//    Replace `YOUR_FLAG_NAME` with the name of the flag you want to toggle. This will toggle the status of the specified feature flag.
//
//    ### Printing Flags
//
//    To print the context of a feature flag, use the `printFlag` task with the `-PflagName=YOUR_FLAG_NAME` argument:
//
//    ```shell
//    gradlew printFlag -PflagName=YOUR_FLAG_NAME
//    ```
//
//    Replace `YOUR_FLAG_NAME` with the name of the flag you want to print. This will print the lines of code that are within the context of the specified feature flag.
//
//    ## For Java/Kotlin/Gradle File Writers
//
//    ### Flag Format
//
//    The expected flag format in your Java/Kotlin/Gradle files is a comment block with the flag name enclosed in angle brackets `<` and `>`. The start and end of the comment block depend on the file type:
//
//    - For Kotlin and Java files, the start of the comment block is `/*` and the end is `*/`.
//    - For XML files, the start of the comment block is `<!--` and the end is `-->`.
//
//    Here's an example of a feature flag in a Kotlin or Java file:
//
//    ```java
//    /* <YOUR_FLAG_NAME> */
//    // Your code here
//    /* </YOUR_FLAG_NAME> */
//    ```
//
//    And here's an example of a feature flag in an XML file:
//
//    ```xml
//            <!-- <YOUR_FLAG_NAME> -->
//            <!-- Your code here -->
//            <!-- </YOUR_FLAG_NAME> -->
//    ```
//
//    Replace `YOUR_FLAG_NAME` with the name of your feature flag.
//
//    ### Context
//
//    The `printFlag` task prints the lines of code that are within the context of the specified feature flag. By default, it prints 5 lines before and after the flag. You can specify a different number of context lines by appending `:NUMBER` to the flag name, where `NUMBER` is the number of context lines you want. For example:
//
//    ```java
//    /* <YOUR_FLAG_NAME:3> */
//    // Your code here
//    /* </YOUR_FLAG_NAME:3> */
//    ```
//
//    This will print 3 lines before and after the flag when you use the `printFlag` task.

class FlagFileDefinition {
    String extension
    String startTag
    String endTag

    FlagFileDefinition(String extension, String startTag, String endTag) {
        this.extension = extension
        this.startTag = startTag
        this.endTag = endTag
    }
}

def flagFileDefinitions = [
        new FlagFileDefinition('.kt', '/*', '*/'),
        new FlagFileDefinition('.java', '/*', '*/'),
        new FlagFileDefinition('.xml', '<!--', '-->')
]

def getFlagsStatus() {
    def flags = [:]
    def projectDir = project.projectDir
    def flagPattern = /\/\* <(.+?)(?::\d+)?>( \*)?/

    projectDir.traverse(type: groovy.io.FileType.FILES, nameFilter: ~/.*\.(java|kt|xml)/) { file ->
        def content = file.text
        content.eachLine { line ->
            def matcher = (line =~ flagPattern)
            if (matcher.find()) {
                String flagName = matcher.group(1)
                if (flagName.startsWith("/")) {
                    return
                }
                if (!flags.containsKey(flagName)) {
                    boolean isEnabled = content.contains("/* <${flagName}> */") || content.contains("/* <${flagName}:\d+> */")
                    flags[flagName] = isEnabled ? "Enabled" : "Disabled"
                }
            }
        }
    }
    return flags
}

tasks.register('listFlags') {
    doLast {
        def flags = getFlagsStatus()
        flags.each { key, value ->
            println "$key: $value"
        }
    }
}

tasks.register('flagHelp') {
    doLast {
        println "Usage: ./gradlew [listFlags|toggleFlag|printFlag] -PflagName=[flagName]"
        println "\nCommands:"
        println "  listFlags: Lists all the feature flags in your project and their current status."
        println "  toggleFlag -PflagName=[flagName]: Toggles the status of the specified feature flag."
        println "  printFlag -PflagName=[flagName]: Prints the lines of code that are within the context of the specified feature flag."
        println "\nExamples:"
        println "  ./gradlew listFlags"
        println "  ./gradlew toggleFlag -PflagName=FLAG_NAME"
        println "  ./gradlew printFlag -PflagName=FLAG_NAME"
    }
}
tasks.register('toggleFlag') {
    doFirst {
        if (!project.hasProperty('flagName')) {
            throw new GradleException("Flag name must be provided using the -PflagName=YOUR_FLAG_NAME argument.")
        }
    }
  doLast {
      String flagName = project.property('flagName')
      def flags = getFlagsStatus()
      boolean isEnabled = flags[flagName] == "Enabled"

      project.projectDir.traverse(type: groovy.io.FileType.FILES, nameFilter: ~/.*\.(java|kt|xml)/) { File file ->
          String content = file.text
          boolean madeReplacement = false

          print(file.absolutePath)
          def flagFileDefinition = flagFileDefinitions.find { file.name.endsWith(it.extension) }
          if (flagFileDefinition == null) {
              println "Unsupported file type: ${file}"
              return
          }

          String startMarkerEnabled = "${flagFileDefinition.startTag} <${flagName}> ${flagFileDefinition.endTag}"
          String endMarkerEnabled = "${flagFileDefinition.startTag} </${flagName}> ${flagFileDefinition.endTag}"
          String startMarkerDisabled = "${flagFileDefinition.startTag} <${flagName}>"
          String endMarkerDisabled = "</${flagName}> ${flagFileDefinition.endTag}"

          if (isEnabled) {
              if (content.contains(startMarkerEnabled) || content.contains(endMarkerEnabled)) {
                  println "Found enabled flag '${flagName}' in file: ${file}"
                  content = content.replaceAll(Pattern.quote(startMarkerEnabled), Matcher.quoteReplacement(startMarkerDisabled))
                  content = content.replaceAll(Pattern.quote(endMarkerEnabled), Matcher.quoteReplacement(endMarkerDisabled))
                  madeReplacement = true
              }
          } else {
              if (content.contains(startMarkerDisabled) || content.contains(endMarkerDisabled)) {
                  println "Found disabled flag '${flagName}' in file: ${file}"
                  content = content.replaceAll(Pattern.quote(startMarkerDisabled), Matcher.quoteReplacement(startMarkerEnabled))
                  content = content.replaceAll(Pattern.quote(endMarkerDisabled), Matcher.quoteReplacement(endMarkerEnabled))
                  madeReplacement = true
              }
          }

          if (madeReplacement) {
              file.text = content
              println "File updated: ${file}"
          } else {
              println "No changes made to file: ${file}"
          }
      }
  }
}

tasks.register('printFlag') {
    doFirst {
        if (!project.hasProperty('flagName')) {
            throw new GradleException("Flag name must be provided using the -PflagName=YOUR_FLAG_NAME argument.")
        }
    }

    doLast {
        String flagName = project.property('flagName')


        Set<String> printedFiles = new HashSet<>()
        Pattern startPattern = Pattern.compile("/\\* <${flagName}(?::(\\d+))?>")
        Pattern endPattern = Pattern.compile("</${flagName}(?::(\\d+))?> \\*/")
        int defaultContextLines = 0

        project.projectDir.traverse(type: groovy.io.FileType.FILES, nameFilter: ~/.*\.(java|kt|xml)/) { File file ->
            List<String> lines = file.readLines()
            boolean isReading = false
            int tagStart = -1
            int contextLinesBefore = defaultContextLines
            int contextLinesAfter = defaultContextLines

            lines.eachWithIndex { line, index ->
                Matcher startMatcher = startPattern.matcher(line)
                if (!isReading && startMatcher.find()) {
                    isReading = true
                    tagStart = index
                    contextLinesBefore = startMatcher.group(1) ? Integer.parseInt(startMatcher.group(1)) : defaultContextLines
                    int contextStart = Math.max(0, index - contextLinesBefore)
                    String fileLabel = "\nFile: ./${projectDir.relativePath(file)}"
                    if (!printedFiles.contains(fileLabel)) {
                        println fileLabel
                        printedFiles.add(fileLabel)
                    } else {
                        println "..."
                    }

                    lines.subList(contextStart, index).each { println "  ${it}" }
                }
                Matcher endMatcher = endPattern.matcher(line)
                if (isReading && endMatcher.find()) {
                    isReading = false
                    int tagEnd = index
                    contextLinesAfter = endMatcher.group(1) ? Integer.parseInt(endMatcher.group(1)) : defaultContextLines
                    int contextEnd = Math.min(lines.size(), tagEnd + contextLinesAfter + 1)
                    lines.subList(tagStart + 1, tagEnd).each { println "+ ${it}" }
                    lines.subList(tagEnd + 1, contextEnd).each { println "  ${it}" }
                }
            }
        }
    }
}